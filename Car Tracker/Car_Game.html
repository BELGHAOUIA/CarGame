<!DOCTYPE html>
<html lang="en">
<head>
    <title>Car Tracker</title>
 <style>
    body {
      /*  margin: 0 auto;*/
      font-family: MyWebFont;
      text-decoration: none;
      /*color: white;*/
      letter-spacing: 5px;
      background-color: rgb(123, 177, 248);
      
    }

    section {
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: rgb(168, 167, 167);
        border-radius: 5px;
    }

     canvas { 
        background-color: black;
        position: fixed;
        margin-top: 12rem;
        border-radius: 5px;
     }


     button {
        border: none;
        background-color: rgb(123, 177, 248);
        letter-spacing: 5px;
        padding: 20px;
        box-shadow: 6px 6px 5px rgba(0, 0, 0, 0.3);
        font-weight: bold;
        border-radius: 5px;
     }

     button:hover {
        box-shadow: 8px 8px 5px rgba(0, 0, 0, 0.8);
     }

     .hidden {
        display: none;
     }

     @font-face {
        font-family: 'MyWebFont';
        src: url('Bombing.ttf');
     }

 </style>
</head>
<body>
    <section>
        <div class="start-screen">
            <h1>Car Tracker</h1>
            <button id="btnS" >Start Game</button>
            <button id="btnR" class="hidden">Pause Game</button>
            <button id="rPlay" class="hidden">Play Again</button>

            <p class="hidden">Hightest Score:</p>
            <p id="hight-score" class="hidden"></p>
        </div>
    <br>
         <canvas id="game"  width="550" height="550">
         </canvas>
    </section>
  <script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  let tileCount = 26;
  let tileSize = canvas.width / tileCount-2;
  let posX = 10;
  let posY = 15;
  let xVelocity = 0;
  let yVelocity = 0;
  let paused = true;
  let speed = 150/7;
  let enemyY = 0;
  let enemyX = 3.5;
  let i=0;
  let j;
  let x;
  let y;
  let timeLine = 0;
  let started = false;
  let roadY = -canvas.height;
  let prizeX = 5;
  let prizeY = 5;
  let prize = 0;
  let carPart1=[6];
  let carPart2=[6];
  let carPart3=[6];
  let dead = false;

  function startGame(){
    if(!dead){
  clearScreen();
  checkWall();
  changeCarPosition();
  checkPrizeCollision();
  drawRoad();

  if(started == true){
    drawPrize();
    drawEnemies();
  }
  drawCar();
  drawTimeline();
  if(timeLine>10 && timeLine % 10 == 0)
  {
    speed-=.1;
  }
  if(timeLine == 30)
  {
    ctx.fillStyle="red";
    ctx.font = "40px Verdana";
    ctx.fillText("HAHAHAHHAAH", (canvas.width/2)-170, canvas.height/2);
    speed-=.2;
  }
  drawScore();
  togglePause(paused);
  gameOver();
  }
}

 // window.onload=function(){
    let el = document.querySelector('#btnS');
     console.log(el);

  if(el){
    el.addEventListener("click", function hideShowing(){
   el = document.querySelector('#btnS');
   el.classList.toggle('hidden');
   el = document.querySelector('#btnR');
   el.classList.toggle('hidden');
   
   if(paused == false){
    paused = true;
   }
   else if(paused == true){
    paused = false;
   }
   started = true;
   startGame();
   console.log(paused);
  });


  }

   el = document.querySelector('#btnR');
     console.log(el);

  if(el){
    el.addEventListener("click", function hideShowing(){
   el = document.querySelector('#btnS');
   el.classList.toggle('hidden');
   el = document.querySelector('#btnR');
   el.classList.toggle('hidden');
   paused = true;
   console.log(paused);
  });

  }

  el = document.querySelector('#rPlay');
     console.log(el);

  if(el){
   el.addEventListener("click", function hideShowing(){
   el = document.querySelector('#btnR');
   el.classList.toggle('hidden');
   el = document.querySelector('#rPlay');
   el.classList.toggle('hidden');
   paused = false;
   started = true;
   dead = false;
   enemyX = 3.5;
   startGame();
   console.log(paused);
  });

  }

//}

function togglePause()
{
    if (paused == false)
    {
      setTimeout(startGame, speed);
    } 
    else if (paused == true && dead == false)
    {
      ctx.fillStyle="red";
      ctx.font = "40px Verdana";
      ctx.fillText("Game Paused", (canvas.width/2)-170, canvas.height/2);

      clearTimeout(game);
    }
}

  function clearScreen(){
  ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
  ctx.fillRect(0,0, canvas.width, canvas.height);
  }


  function drawRoad() {
    // Grass background
    ctx.fillStyle = "#0b8457";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Road
    ctx.fillStyle = "#7d7d7d";
    ctx.fillRect(75, 0, 400, canvas.height);

    // Road borders (yellow lines)
    ctx.fillStyle = "#ffcc00";
    ctx.fillRect(75, 0, 5, canvas.height); // Left border
    ctx.fillRect(470, 0, 5, canvas.height); // Right border

    // Center dashed line
    ctx.fillStyle = "white";
    const dashHeight = 40;
    const dashGap = 30;
    for (let y = 0; y < canvas.height; y += dashHeight + dashGap) {
        ctx.fillRect(270, y, 10, dashHeight);
    }
}



  function drawCar() {
    const baseX = posX * tileCount;
    const baseY = posY * tileCount;

    // ==== Car Body ====
    ctx.fillStyle = "#1cb3c8"; // main color
    ctx.fillRect(baseX, baseY, tileSize * 2, tileSize * 4);

    // ==== Cabin ====
    ctx.fillStyle = "white"; 
    ctx.fillRect(baseX, baseY + tileSize, tileSize * 2, tileSize * 2);

    // ==== Windshield ====
    ctx.fillStyle = "rgb(123, 177, 248)";
    ctx.fillRect(baseX + 4, baseY + 2, tileSize * 2 - 8, tileSize);

    // ==== Wheels ====
    ctx.fillStyle = "black";
    // front wheels
    ctx.fillRect(baseX - 4, baseY + 4, 4, tileSize); // left front
    ctx.fillRect(baseX + tileSize * 2, baseY + 4, 4, tileSize); // right front
    // rear wheels
    ctx.fillRect(baseX - 4, baseY + tileSize * 4 - tileSize - 4, 4, tileSize); // left rear
    ctx.fillRect(baseX + tileSize * 2, baseY + tileSize * 4 - tileSize - 4, 4, tileSize); // right rear

    // ==== Highlight Stripe (optional) ====
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(baseX + tileSize - 1, baseY, 2, tileSize * 4);
}

  function drawEnemies(){
    carPart1[0] = enemyY-50*30;
    carPart2[0] = enemyY-50*30;
    carPart3[0] = 7+enemyY-50*30;
    drawOneEnemy(2,carPart1[0],carPart2[0],carPart3[0]);
   
    carPart1[1] = enemyY-30*30;
    carPart2[1] = enemyY-30*30;
    carPart3[1] = 7+enemyY-30*30;
    drawOneEnemy(4,carPart1[1],carPart2[1],carPart3[1]);
   
    carPart1[2] = enemyY-20*10;
    carPart2[2] = enemyY-20*10;
    carPart3[2] = 7+enemyY-20*10;
    drawOneEnemy(6,carPart1[2],carPart2[2],carPart3[2]);
   
    carPart1[3] = enemyY-10*60;
    carPart2[3] = enemyY-10*60;
    carPart3[3] = 7+enemyY-10*60;
    drawOneEnemy(10,carPart1[3],carPart2[3],carPart3[3]);

    carPart1[4] = enemyY-10*50;
    carPart2[4] = enemyY-10*50;
    carPart3[4] = 7+enemyY-10*50;
    drawOneEnemy(3.5,carPart1[4],carPart2[4],carPart3[4]);

    carPart1[5] = enemyY-50*25;
    carPart2[5] = enemyY-50*25;
    carPart3[5] = 7+enemyY-50*25;
    drawOneEnemy(0,carPart1[5],carPart2[5],carPart3[5]);

    enemyY+=10;

  } // Predefined set of colors for variety
const enemyColors = [
    "#8f1d14", // dark red
    "#1d8f2a", // green
    "#1d3d8f", // blue
    "#8f1d7d", // purple
    "#8f6f1d", // gold/brown
    "#000000"  // black
];

// Store a fixed color for each enemy (same index as carPart arrays)
let enemyCarColors = Array(6).fill(null).map(() => 
    enemyColors[Math.floor(Math.random() * enemyColors.length)]
);

function drawEnemies() {
    // Enemy 0
    carPart1[0] = enemyY - 50 * 30;
    carPart2[0] = enemyY - 50 * 30;
    carPart3[0] = 7 + enemyY - 50 * 30;
    drawOneEnemyColored(2, carPart1[0], carPart2[0], carPart3[0], enemyCarColors[0]);

    // Enemy 1
    carPart1[1] = enemyY - 30 * 30;
    carPart2[1] = enemyY - 30 * 30;
    carPart3[1] = 7 + enemyY - 30 * 30;
    drawOneEnemyColored(4, carPart1[1], carPart2[1], carPart3[1], enemyCarColors[1]);

    // Enemy 2
    carPart1[2] = enemyY - 20 * 10;
    carPart2[2] = enemyY - 20 * 10;
    carPart3[2] = 7 + enemyY - 20 * 10;
    drawOneEnemyColored(6, carPart1[2], carPart2[2], carPart3[2], enemyCarColors[2]);

    // Enemy 3
    carPart1[3] = enemyY - 10 * 60;
    carPart2[3] = enemyY - 10 * 60;
    carPart3[3] = 7 + enemyY - 10 * 60;
    drawOneEnemyColored(10, carPart1[3], carPart2[3], carPart3[3], enemyCarColors[3]);

    // Enemy 4
    carPart1[4] = enemyY - 10 * 50;
    carPart2[4] = enemyY - 10 * 50;
    carPart3[4] = 7 + enemyY - 10 * 50;
    drawOneEnemyColored(3.5, carPart1[4], carPart2[4], carPart3[4], enemyCarColors[4]);

    // Enemy 5
    carPart1[5] = enemyY - 50 * 25;
    carPart2[5] = enemyY - 50 * 25;
    carPart3[5] = 7 + enemyY - 50 * 25;
    drawOneEnemyColored(0, carPart1[5], carPart2[5], carPart3[5], enemyCarColors[5]);

    // Move all enemies
    enemyY += 10;
}

function drawOneEnemyColored(x, carPart1, carPart2, carPart3, bodyColor) {
    const baseX = enemyX * tileCount + (x * tileCount);

    // ==== Car Body ====
    ctx.fillStyle = bodyColor;
    ctx.fillRect(baseX, carPart1, tileSize * 2, tileSize * 4);

    // ==== Cabin ====
    ctx.fillStyle = "black";
    ctx.fillRect(baseX, carPart2, tileSize * 2, tileSize * 2);

    // ==== Windshield ====
    ctx.fillStyle = "#913535";
    ctx.fillRect(baseX + 4, carPart3, tileSize * 2 - 8, tileSize);

    // ==== Wheels ====
    ctx.fillStyle = "black";
    ctx.fillRect(baseX - 4, carPart1 + 4, 4, tileSize);
    ctx.fillRect(baseX + tileSize * 2, carPart1 + 4, 4, tileSize);
    ctx.fillRect(baseX - 4, carPart1 + tileSize * 4 - tileSize - 4, 4, tileSize);
    ctx.fillRect(baseX + tileSize * 2, carPart1 + tileSize * 4 - tileSize - 4, 4, tileSize);

    // ==== Racing Stripe ====
    ctx.fillStyle = "#ffcc00";
    ctx.fillRect(baseX + tileSize - 2, carPart1, 4, tileSize * 4);
}

function drawTimeline() {
    // Format timeLine into minutes and seconds with leading zeros
    const minutes = Math.floor(timeLine / 60);
    const seconds = timeLine % 60;
    const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

    ctx.fillStyle = "#913535";
    ctx.font = "20px Verdana";
    ctx.shadowColor = "rgba(0, 0, 0, 0.4)";
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    ctx.shadowBlur = 2;
    ctx.textAlign = "left";

    ctx.fillText("Time " + formattedTime, 10, 25);

    // Increment timeLine once per second if game started
    // (assuming drawTimeline is called more than once per second)
    if (started) {
        // Use a timer variable outside to control incrementation rate
        if (!drawTimeline.lastUpdate) drawTimeline.lastUpdate = Date.now();
        const now = Date.now();
        if (now - drawTimeline.lastUpdate >= 1000) {
            timeLine++;
            drawTimeline.lastUpdate = now;
        }
    }
}


  function drawRoadLine(){
    ctx.fillStyle = "white";
    ctx.fillRect(4*tileSize, 0, 2, canvas.height);
    ctx.fillRect(24.6*tileSize, 0, 2, canvas.height);

    for(j=0;j<100;j++)
    {
      ctx.fillRect(canvas.width/2, roadY+j*100, 2, canvas.height/tileSize);
    }
    roadY++;

  }

  drawRoadLine();

  const minutes = Math.floor(timeLine / 60);
  const seconds = timeLine % 60;
  const timeText = `${minutes}m ${seconds}s`;


  function drawScore() {
    ctx.fillStyle = "#f89d13";
    ctx.font = "bold 22px Verdana";
    ctx.shadowColor = "rgba(0,0,0,0.4)";
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.shadowBlur = 3;

    ctx.textAlign = "left";  // Fix alignment to left

    const text = "Score: " + prize;
    const x = canvas.width - 160;
    const y = 30;

    ctx.fillText(text, x, y);

    // Draw a small star icon to the left of the text
    const starX = x - 30;
    const starY = y - 12;
    ctx.fillStyle = "#ffd700";
    ctx.beginPath();
    const spikes = 5;
    const outerRadius = 10;
    const innerRadius = 5;
    let rot = Math.PI / 2 * 3;
    let step = Math.PI / spikes;
    ctx.moveTo(starX, starY - outerRadius);
    for (let i = 0; i < spikes; i++) {
        ctx.lineTo(starX + Math.cos(rot) * outerRadius, starY + Math.sin(rot) * outerRadius);
        rot += step;
        ctx.lineTo(starX + Math.cos(rot) * innerRadius, starY + Math.sin(rot) * innerRadius);
        rot += step;
    }
    ctx.closePath();
    ctx.fill();

    // Reset shadow and alignment so it doesn't affect other drawings
    ctx.shadowColor = "transparent";
    ctx.textAlign = "start";
}


function drawPrize() {
    const x = prizeX * tileCount;
    const y = prizeY;
    const size = tileSize;

    // ==== Glow ====
    const glow = ctx.createRadialGradient(x + size / 2, y + size / 2, size * 0.2, x + size / 2, y + size / 2, size * 0.8);
    glow.addColorStop(0, "#ffd27f");
    glow.addColorStop(1, "#f89d13");

    // ==== Main Shape ====
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.roundRect(x, y, size, size, 6);
    ctx.fill();

    // ==== Border ====
    ctx.strokeStyle = "#ffeb99";
    ctx.lineWidth = 2;
    ctx.stroke();

    // ==== Star Icon ====
    ctx.fillStyle = "#fff4d1";
    ctx.beginPath();
    const cx = x + size / 2;
    const cy = y + size / 2;
    const spikes = 5;
    const outerRadius = size / 3;
    const innerRadius = size / 6;
    let rot = Math.PI / 2 * 3;
    let step = Math.PI / spikes;
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
        rot += step;
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
        rot += step;
    }
    ctx.closePath();
    ctx.fill();

    // ==== Movement ====
    prizeY += 10;
}


    function changeCarPosition(){
    posX = posX + xVelocity;
    posY = posY + yVelocity;
   }

   let max = 17;
   let min = 3;

   function checkWall(){
             
          if(prizeY > canvas.height)
          {
            prizeY = 0;

           // prizeX = Math.floor(Math.random()* 18);
           // console.log("------prizeX------", prizeX);

           // while(prizeX* tileCount < 3 && prizeX* tileCount > 17.3)
              prizeX = Math.floor(Math.random() * (max - min + 1)) + min;
           // console.log("------prizeX------", prizeX);

          }

          if(roadY+j*100 > canvas.height)
          {
            console.log(roadY);
            j = 0;
            roadY = 0;
            drawRoadLine();
          }

          if(carPart1[0] > canvas.height)
          {
            enemyY = 0;
           // carPart1 = carPart2 = carPart3 = 0;
           // y = 0;
          }

          if(posX < 2 && posX > 18)
          {
            speed = 1000;
          }

   }
document.body.addEventListener("keydown", keyDown);
document.body.addEventListener("keyup",keyUp)

  function keyUp(event){
    xVelocity = 0;
    yVelocity = 0;
  }
  function keyDown(event){
 
    //up && down disabled
    /*if(event.keyCode == 38){
        yVelocity = -0.2;
    }

    if(event.keyCode == 40){
        yVelocity = 0.2;
    }
*/
    //started = true;

    //right && left
    if(event.keyCode == 37){
        xVelocity = -0.2;
    }

    if(event.keyCode == 39){
        xVelocity = 0.2;
    }
}

function testCondition1(x, y){
    if(posX* tileCount >= enemyX* tileCount+(x*tileCount) && posX* tileCount <= enemyX* tileCount+(x*tileCount)+tileSize*2){
       if(posY* tileCount >= carPart1[y] && posY* tileCount <= carPart1[y]+tileSize*4)
         {
              return 1;
         }
         else if(posY* tileCount+tileSize*4 >= carPart1[y] && posY* tileCount+tileSize*4 <= carPart1[y]+tileSize*4)
         {
             return 1;
         }
     }
    else return 0;

}

function testCondition2(x, y){
    if(posX* tileCount+tileSize*2 >= enemyX* tileCount+(x*tileCount) && posX* tileCount+tileSize*2 <= enemyX* tileCount+(x*tileCount)+tileSize*2){
       if(posY* tileCount >= carPart1[y] && posY* tileCount <= carPart1[y]+tileSize*4)
         {
              return 1;
         }
         else if(posY* tileCount+tileSize*4 >= carPart1[y] && posY* tileCount+tileSize*4 <= carPart1[y]+tileSize*4)
         {
             return 1;
         }
     }
    else return 0;

}


function gameOver(){

             
         /* if(posX* tileCount >= enemyX* tileCount+(2*tileCount) && posX* tileCount <= enemyX* tileCount+(2*tileCount)+tileSize*2){
            if(posY* tileCount >= carPart1[0] && posY* tileCount <= carPart1[0]+tileSize*4)*/
            if(testCondition1(2,0) === 1 || testCondition1(4,1) === 1 || testCondition1(6,2) === 1 || testCondition1(10,3) === 1 || testCondition1(3.5,4) === 1 || testCondition1(0,5))
            {
              dead = true;
              if(dead == true && paused == false)
             youDied();
            }
            else if(testCondition2(2,0) === 1 || testCondition2(4,1) === 1 || testCondition2(6,2) === 1 || testCondition2(10,3) === 1 || testCondition2(3.5,4) === 1 || testCondition2(0,5))
            {
              dead = true;
              if(dead == true && paused == false)
             youDied();
            }

}

function youDied() {
    speed = 150 / 7;
    const elPlay = document.querySelector('#rPlay');
    const elBtnR = document.querySelector('#btnR');
    elPlay.classList.toggle('hidden');
    elBtnR.classList.toggle('hidden');
    paused = true;

    clearScreen();

    // Dark semi-transparent overlay
    ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // YOU DIED! text with shadow & glow
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    ctx.textAlign = "center";

    // Animate pulse (scale up/down)
    const pulse = 1 + 0.05 * Math.sin(Date.now() / 200);
    ctx.save();
    ctx.translate(centerX, centerY - 30);
    ctx.scale(pulse, pulse);

    ctx.fillStyle = "red";
    ctx.shadowColor = "rgba(255, 0, 0, 0.7)";
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.font = "bold 60px Verdana";
    ctx.fillText("YOU DIED!", 0, 0);
    ctx.restore();

    // Format time as minutes and seconds
    const minutes = Math.floor(timeLine / 60);
    const seconds = timeLine % 60;
    const timeText = `${minutes}m ${seconds}s`;

    // Score and time info
    ctx.fillStyle = "limegreen";
    ctx.shadowColor = "rgba(0, 128, 0, 0.5)";
    ctx.shadowBlur = 10;
    ctx.font = "28px Verdana";
    ctx.fillText("Score: " + prize, centerX, centerY + 40);
    ctx.fillText("Time elapsed: " + timeText, centerX, centerY + 80);

    // Reset game values
    prize = 0;
    timeLine = 0;
    started = false;
    enemyX = 0;
    enemyY = 0;
}

function checkPrizeCollision(){
     
  if(prizeX* tileCount >= posX* tileCount && prizeX* tileCount <= posX* tileCount+tileSize*2){
       if(prizeY >= posY* tileCount && prizeY <= posY* tileCount + tileSize*4)
         {
              prize++;
              prizeY = canvas.height;
         }
  }
  else if(prizeX* tileCount+tileSize >= posX* tileCount && prizeX* tileCount+tileSize <= posX* tileCount+tileSize*2){
        if(prizeY >= posY* tileCount && prizeY <= posY* tileCount+tileSize*4)
         {
              prize++;
              prizeY = canvas.height;
         }
    }

}
  </script>


</body>
</html>
